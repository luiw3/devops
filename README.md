# devops

## Linux

1. Folders structure
2. Networking
    1. Reverse proxy
    2. DNS
    3. Firewall
3. Disk management
4. Processes management        
5. Useful commands
6. Vim advanced
7. bash scripting

## Docker

1. Container networking
2. Swarm
3. Load balance
4. Image maintenance

## AWS

## Golang

## CI/CD and Jenkins

1. **CI Continuous integration**
    1.  The dev teams will work on the code and when they finish their work and merge their branches into the base code it will automatically execute integration routines like run automated tests, build and deploy the application assuring that the code being merged doesn’t have any problems
2. **CD Continuous Delivery** 
    1. Means you should be able to deploy any build of your software to your clients at anytime without errors extending it to Continuous Deployment automating the deploy of your code to a production environment after the continuous integration routine
3. **Jenkins**
    1. needs java 8 or java 11 in the host machine, after installation  you have to start the service running:
        
        ```bash
        systemctl start jenkins.service
        systemctl enable jenkings.service
        ```
        
        check if 8080/8090 port is in use and free to receive connections go to {your-host}:{jenkinsport} and start configuring the plugins and admin access
        
    2.  We have the master node which essentially is a controller that sends instructions to the workers nodes, the workers nodes dont need to have jenkins installed only the correct java version, the jenkins agent is a .jar file that will be installed in all worker nodes
    3.  Master node also monitors the workers nodes and record the output
    4.  ***Jobs***
        1.  All software required for the build must be installed in jenkins server machine
        2.  Also we have to check if the jenkins user has all needed permissions to execute scripts/build steps (By default jenkins uses a user named jenkins to execute all build steps)
        3.  You can schedule a job to check if there are any changes in the code repository using jenkins cron syntax
            
             * * * * *
            
                   Days of the week (0-6)
            
               Month of the year (1-12)
            
             Day of the month (1-31)
            
             Hour (0-23)
            
             Minute (0-59)
            
        
          * → All valid values
        
        M-N → Range starting in M and ending in N
        
        A,B,C → Three specific timestamps
        
        And then Jenkins will periodically checks for this changes, if anything changed it will execute the build script again otherwise it’ll only say that the code is up to date
        
    5. ***Archives*** (How to save files outside the workspace)
        1.  You can configure which files jenkins generate you will save ( i.e for deploy purposes)
        2.  Saving the generated build artifact you can then use the copy artifact plugin to get it and do the next steps needed to deploy
    6.  ***Pipelines***
        1. It is a chain of jobs that are executed to deploy the application, each step on a pipeline can be automatic or configured to run manually by an authorized user
        2.  In a high level consist of three steps
            1.  Building and testing and deployable artifact (Unit tests, e2e tests, etc)
            2.  Quality Assurance (Cyclomatic complexity, bug detection, code coverage metrics)
            3.  Orchestrating the deploy to production (Deploy the approved artifact to requested environment be it dev, stating or prod, running needed QA tasks in each one)
    7.  ***Jenkins as IAC***
        1.  Issues with configuring Jenkins jobs via the GUI involves a lot of users with permissions to create and modify jobs without the ability to track down these changes. To avoid that we are able to write the job in code and store it in git
        2.  You can tag important pipelines changes in git and rollback to a previous version quickly in case your changes in the jenkins code goes wrong
        3.  Groovy DSL
            1. With DSL written in Groovy language it is possible to automate the process of job creation 
                - [ ]  Learn more about groovy language and jenkins DSL
                
                ```groovy
                job('First-Maven-Project-Via-DSL') {
                    description("First Maven job generated by the DSL on ${new Date()}, the project is a small Maven project hosted on github")
                    scm {
                        git("https://github.com/anshulc55/Jenkins_Upgradev3.git", 'master')
                    }
                    triggers {
                        scm('* * * * *')
                    }
                    steps {
                        maven('clean package', 'maven-samples/single-module/pom.xml')
                    }
                    publishers {
                        //archive the war file generated
                        archiveArtifacts '**/*.jar'
                    }
                }
                ```
                
        4.  Jenkinsfile
            1. Jenkinsfile is writen in groovy
        

## Ansible/Terraform

1. Terraform
    1. Create the infrastructure
    2. abstract the need of detailed instructions
    3.  get current state, plan the changes needed and apply them afterwards
2. Ansible
    1. automate I.T tasks
    2. set of instructions to execute in a certain order in one or more remote hosts
    3.  connect to servers using SSH protocol with the current user selected by default being possible to overwrite it
    4.  group a set of hosts to execute the playbook

## Prometheus

## Kubernetes

## GIT

1. Revert vs Reset
    1. Revert - use when the changes are pushed to remote once it will create a new commit undoing the changes of the pointed commit
    2. Reset - use when commited but not pushed to remote, it will discard the commit and revert the files previous state
        1. —soft will only undo the commit but not the changes to the files
        2. —hard will reset the commit history and the changes on the files

## Managing VMs

Learn to fully automate the deployment of your application.

Learn how to automate the provisioning of the infrastructure of your application